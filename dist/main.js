/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/UI.js":
/*!*******************!*\
  !*** ./src/UI.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ UI)\n/* harmony export */ });\nclass UI {\r\n\tconstructor() {}\r\n\r\n\tinitArrow() {\r\n\t\tconst arrowIcon = document.getElementsByClassName(\"arrow-icon\")[0];\r\n\r\n\t\tarrowIcon.addEventListener(\"click\", () => {\r\n\t\t\twindow.scrollTo({ top: window.innerHeight, behavior: \"smooth\" });\r\n\t\t});\r\n\t}\r\n\r\n\tinitResizeableNav() {\r\n\t\t// Controlling the navbar when page gets too narrow\r\n\t\tconst toggleButton = document.getElementsByClassName(\"toggle-button\")[0];\r\n\t\tconst mobileMenu = document.getElementsByClassName(\"mobile-nav\")[0];\r\n\r\n\t\ttoggleButton.addEventListener(\"click\", () => {\r\n\t\t\tmobileMenu.classList.toggle(\"active\");\r\n\t\t});\r\n\r\n\t\twindow.addEventListener(\"resize\", () => {\r\n\t\t\tif (window.matchMedia(\"(min-width: 600px)\").matches) {\r\n\t\t\t\tmobileMenu.classList.remove(\"active\");\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tinitInfoTabs() {\r\n\t\tconst infoContainers = document.getElementsByClassName(\"info\");\r\n\t\tfor (const infoContainer of infoContainers) {\r\n\t\t\tconst boundHandleSwitchInfoTab = this.handleSwitchInfoTab.bind(this);\r\n\t\t\tinfoContainer.addEventListener(\"click\", boundHandleSwitchInfoTab);\r\n\t\t}\r\n\t}\r\n\r\n\thandleSwitchInfoTab(e) {\r\n\t\tconst containers = document.getElementsByClassName(\"info\");\r\n\t\tfor (const container of containers) {\r\n\t\t\tcontainer.classList.remove(\"active\");\r\n\t\t}\r\n\r\n\t\te.target.classList.toggle(\"active\");\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/UI.js?");

/***/ }),

/***/ "./src/character.js":
/*!**************************!*\
  !*** ./src/character.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Character)\n/* harmony export */ });\nclass Character {\r\n\tconstructor(gameWidth, gameHeight, name, pos, id, assets, ctx) {\r\n\t\tthis.gameHeight = gameHeight;\r\n\t\tthis.gameWidth = gameWidth;\r\n\t\tthis.id = id;\r\n\r\n\t\t// character visuals\r\n\t\tthis.height = 80;\r\n\t\tthis.width = 80;\r\n\t\tthis.name = name;\r\n\t\tthis.nameLength = ctx.measureText(this.name);\r\n\t\tthis.image;\r\n\t\tthis.imageWinning;\r\n\t\tthis.imageTimer = 0;\r\n\t\tthis.imageTimerMax = 125;\r\n\t\tthis.border = 0;\r\n\t\tthis.spacing = 0;\r\n\t\tthis.row = 2;\r\n\t\tthis.col = 0;\r\n\r\n\t\tthis.assets = assets;\r\n\r\n\t\tthis.directions = {\r\n\t\t\tRIGHT: \"right\",\r\n\t\t\tLEFT: \"left\",\r\n\t\t};\r\n\t\tthis.facing = this.directions.RIGHT;\r\n\r\n\t\tthis.spriteDict;\r\n\r\n\t\t// character movement\r\n\t\tthis.speed = 75;\r\n\t\tthis.maxSpeed = 100;\r\n\t\tthis.velocity = { x: 50, y: 50 };\r\n\t\tthis.goal = { x: 0, y: 0 };\r\n\t\tthis.position = pos;\r\n\r\n\t\tthis.states = {\r\n\t\t\tRUNNING: \"running\",\r\n\t\t\tKNOCKBACKED: \"knockedback\",\r\n\t\t\tATTACKING: \"attacking\",\r\n\t\t\tWINNING: \"winning\",\r\n\t\t\tDEAD: \"dead\",\r\n\t\t};\r\n\r\n\t\tthis.status = this.states.RUNNING;\r\n\r\n\t\tthis.time = 0;\r\n\t\tthis.attackTimer = 0;\r\n\t\tthis.attackCD = 900;\r\n\r\n\t\t// character attributes\r\n\t\tthis.maxHealth = 100;\r\n\t\tthis.health = 100;\r\n\t\tthis.dmg = 10;\r\n\t}\r\n\r\n\t// Drawing methods\r\n\r\n\tdraw(ctx, dt) {\r\n\t\tthis.imageTimer += dt;\r\n\t\tctx.fillStyle = \"#f00\";\r\n\t\t// draws name\r\n\t\tctx.fillText(this.name, this.position.x - this.nameLength.width / 2 + 40, this.position.y + this.height + 20);\r\n\r\n\t\t// if they are not dead, draw health and attack cooldown timer\r\n\t\tif (this.status != this.states.DEAD) {\r\n\t\t\tthis.drawHealth(ctx);\r\n\t\t\tthis.drawAttackCD(ctx);\r\n\t\t}\r\n\r\n\t\t// decides what to draw depending on state of character\r\n\t\tswitch (this.status) {\r\n\t\t\tcase this.states.RUNNING:\r\n\t\t\t\tthis.drawSpriteRunning(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.KNOCKBACKED:\r\n\t\t\t\tthis.drawSpriteKBed(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.ATTACKING:\r\n\t\t\t\tthis.drawSpriteAttacking(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.WINNING:\r\n\t\t\t\tthis.drawSpriteWinning(ctx);\r\n\t\t\t\tbreak;\r\n\t\t\tcase this.states.DEAD:\r\n\t\t\t\tthis.drawSpriteDead(ctx);\r\n\t\t}\r\n\r\n\t\t// handles sprite images, depending on time length per sprite frame\r\n\t\t// if timer for frame is up, move to next frame in animation\r\n\t\tif (this.imageTimer > this.imageTimerMax) {\r\n\t\t\tthis.col += 1;\r\n\t\t\tthis.imageTimer = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// draw health\r\n\tdrawHealth(ctx) {\r\n\t\tctx.fillStyle = \"lime\";\r\n\t\tctx.font = \"20px Arial\";\r\n\t\tctx.fillRect(this.position.x, this.position.y + this.height + 35, (this.health / this.maxHealth) * this.width, 10);\r\n\t\tctx.fillText(this.health + \" HP\", this.position.x, this.position.y + this.height + 35);\r\n\t}\r\n\r\n\t// draw attack cooldown\r\n\tdrawAttackCD(ctx) {\r\n\t\tctx.fillStyle = \"blue\";\r\n\t\tctx.fillRect(this.position.x, this.position.y + this.height + 50, (this.attackTimer / this.attackCD) * this.width, 10);\r\n\t}\r\n\r\n\t// draw running\r\n\tdrawSpriteRunning(ctx) {\r\n\t\t// sprite is constant loop over sprite animation\r\n\t\tlet sprite = this.getSpriteConstantLoop(\"running\");\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draw attacking\r\n\tdrawSpriteAttacking(ctx) {\r\n\t\t// sprite is only one loop - stops on last frame of animation\r\n\t\tlet sprite = this.getSpriteOneLoop(\"attacking\");\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draws if character is KBed\r\n\tdrawSpriteKBed(ctx) {\r\n\t\t// sprite is only one loop - stops on last frame of animation\r\n\t\tlet sprite = this.getSpriteOneLoop(\"knockedback\");\r\n\t\tctx.fillText(\"KBed\", this.position.x + this.width / 2 - ctx.measureText(\"KBed\").width / 2, this.position.y - 10);\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draws if character has won\r\n\tdrawSpriteWinning(ctx) {\r\n\t\t// runs on constant loop, draws WINNER text\r\n\t\tlet sprite = this.getSpriteConstantLoop(\"winning\");\r\n\t\tctx.fillStyle = \"fuchsia\";\r\n\t\tctx.fillText(\"WINNER\", this.position.x + this.width / 2 - ctx.measureText(\"WINNER\").width / 2, this.position.y - 10);\r\n\r\n\t\t// draw reverse depending on velocity on x axis\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.imageWinning, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.imageWinning, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// draws character lying prone on ground\r\n\tdrawSpriteDead(ctx) {\r\n\t\tlet sprite = this.getSpriteOneLoop(\"knockedback\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t// each sprite frame is 80x80 so turns col/row into x/y coords\r\n\tspritePositionToImagePosition(col, row) {\r\n\t\treturn {\r\n\t\t\tx: this.border + col * (this.spacing + this.width),\r\n\t\t\ty: this.border + row * (this.spacing + this.height),\r\n\t\t};\r\n\t}\r\n\r\n\t// constant loop - if column gets to end of sprite sheet, reset back to beginning\r\n\tgetSpriteConstantLoop(condition) {\r\n\t\tif (this.col == this.spriteDict[condition][1][0]) {\r\n\t\t\tthis.col = this.spriteDict[condition][0][0];\r\n\t\t}\r\n\r\n\t\treturn this.spritePositionToImagePosition(this.col, this.row);\r\n\t}\r\n\r\n\t// one loop - if column gets to end, stay on the last frame\r\n\tgetSpriteOneLoop(condition) {\r\n\t\tif (this.col == this.spriteDict[condition][1][0]) {\r\n\t\t\tthis.col = this.spriteDict[condition][1][0] - 1;\r\n\t\t}\r\n\r\n\t\treturn this.spritePositionToImagePosition(this.col, this.row);\r\n\t}\r\n\r\n\t// set sprite frame - called when character changes state so animation can change\r\n\tsetSprite(condition) {\r\n\t\tthis.col = this.spriteDict[condition][0][0];\r\n\t\tthis.row = this.spriteDict[condition][0][1];\r\n\t}\r\n\r\n\t// Most getters and setters\r\n\r\n\tgetName() {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tgetPosition() {\r\n\t\treturn this.position;\r\n\t}\r\n\r\n\tsetPosition(newX, newY) {\r\n\t\tthis.position.x = newX;\r\n\t\tthis.position.y = newY;\r\n\t}\r\n\r\n\taddPosition(dx, dy) {\r\n\t\tthis.position.x += dx;\r\n\t\tthis.position.y += dy;\r\n\t}\r\n\r\n\tgetVelocity() {\r\n\t\treturn this.velocity;\r\n\t}\r\n\r\n\tsetVX(vx) {\r\n\t\tthis.velocity.x = vx;\r\n\t}\r\n\r\n\tmultiplyVX(multiple) {\r\n\t\tthis.velocity.x *= multiple;\r\n\t}\r\n\r\n\tsetVY(vy) {\r\n\t\tthis.velocity.y = vy;\r\n\t}\r\n\r\n\tmultiplyVY(multiple) {\r\n\t\tthis.velocity.y *= multiple;\r\n\t}\r\n\r\n\tgetHeight() {\r\n\t\treturn this.height;\r\n\t}\r\n\r\n\tgetWidth() {\r\n\t\treturn this.width;\r\n\t}\r\n\r\n\tgetGoal() {\r\n\t\treturn this.goal;\r\n\t}\r\n\r\n\tgetTimeKnockedback() {\r\n\t\treturn this.time;\r\n\t}\r\n\r\n\taddTimeKnockedback(dt) {\r\n\t\tthis.time += dt;\r\n\t}\r\n\r\n\tsetTimeKnockedback(dt) {\r\n\t\tthis.time = dt;\r\n\t}\r\n\r\n\tminusHealth(dmg) {\r\n\t\tthis.health -= dmg;\r\n\t}\r\n\r\n\tisDead() {\r\n\t\tif (this.health <= 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tgetAttackTimer() {\r\n\t\treturn this.attackTimer;\r\n\t}\r\n\r\n\tsetAttackTimer(time) {\r\n\t\tthis.attackTimer = time;\r\n\t}\r\n\r\n\tcooldownAttackTimer(dt) {\r\n\t\tif (this.attackTimer - dt < 0) {\r\n\t\t\tthis.attackTimer = 0;\r\n\t\t} else {\r\n\t\t\tthis.attackTimer -= dt;\r\n\t\t}\r\n\t}\r\n\r\n\tgetTimeForAttackAnimation() {\r\n\t\treturn this.timeforAttackAnimation;\r\n\t}\r\n\r\n\tgetID() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tgetFacing() {\r\n\t\treturn this.facing;\r\n\t}\r\n\r\n\tsetFacing(dir) {\r\n\t\tthis.facing = dir;\r\n\t}\r\n\r\n\tsetStatus(status) {\r\n\t\tthis.status = status;\r\n\t}\r\n\r\n\tgetStatus() {\r\n\t\treturn this.status;\r\n\t}\r\n\r\n\tgetDmg() {\r\n\t\treturn this.dmg;\r\n\t}\r\n\r\n\t// Movement related methods\r\n\r\n\t// keeps character inside field\r\n\tkeepInside() {\r\n\t\tif (this.position.x <= 1) {\r\n\t\t\tthis.position.x = 5;\r\n\t\t\tthis.velocity.x = 0;\r\n\t\t}\r\n\r\n\t\tif (this.position.x >= this.gameWidth - this.width - 1) {\r\n\t\t\tthis.position.x = this.gameWidth - this.width - 5;\r\n\t\t\tthis.velocity.x = 0;\r\n\t\t}\r\n\r\n\t\tif (this.position.y <= 80) {\r\n\t\t\tthis.position.y = 81;\r\n\t\t\tthis.velocity.y = 0;\r\n\t\t}\r\n\r\n\t\tif (this.position.y >= this.gameHeight - this.height - 1) {\r\n\t\t\tthis.position.y = this.gameHeight - this.height - 5;\r\n\t\t\tthis.velocity.y = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t// finds closest enemy and returns it\r\n\tgetClosestEnemy(characterList) {\r\n\t\tlet closest;\r\n\t\tlet closestDist = 999999;\r\n\t\tfor (let i = 0; i < characterList.length; i++) {\r\n\t\t\tlet dist = this.getDist(characterList[i]);\r\n\t\t\tif (dist < closestDist && characterList[i].getID() != this.id && characterList[i].getStatus() != this.states.KNOCKBACKED) {\r\n\t\t\t\tclosestDist = dist;\r\n\t\t\t\tclosest = characterList[i];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn closest;\r\n\t}\r\n\r\n\t// sets goal to closest enemy - if the goal is null,stop moving as character has won\r\n\tsetGoal(character) {\r\n\t\tif (character != null) {\r\n\t\t\tthis.goal = character.getPosition();\r\n\t\t} else {\r\n\t\t\tthis.goal = { x: this.position.x, y: this.position.y };\r\n\t\t\tthis.velocity.x = 0;\r\n\t\t\tthis.velocity.y = 0;\r\n\t\t}\r\n\t}\r\n\r\n\t//some get functions relating to movement\r\n\r\n\tgetGoal() {\r\n\t\treturn this.goal;\r\n\t}\r\n\r\n\t// gets dist from character\r\n\tgetDist(character) {\r\n\t\tlet pos = character.getPosition();\r\n\t\tlet part1 = Math.pow(this.position.x - pos.x, 2);\r\n\t\tlet part2 = Math.pow(this.position.y - pos.y, 2);\r\n\r\n\t\treturn Math.pow(part1 + part2, 0.5);\r\n\t}\r\n\r\n\t// turns distance into a unit vector\r\n\tgetUnitVector() {\r\n\t\tlet part1 = this.goal.x - this.position.x;\r\n\t\tlet part2 = this.goal.y - this.position.y;\r\n\t\tlet magnitude = Math.pow(Math.pow(part1, 2) + Math.pow(part2, 2), 0.5);\r\n\r\n\t\treturn { x: part1 / magnitude, y: part2 / magnitude };\r\n\t}\r\n\r\n\t// update movement of character based on goal\r\n\tupdateVelocities() {\r\n\t\tlet d1 = this.goal.x - this.position.x;\r\n\t\tlet d2 = this.goal.y - this.position.y;\r\n\r\n\t\t// checking to see if distance to goal == 0\r\n\t\tif (d1 != 0 && d2 != 0) {\r\n\t\t\t// gets a unit vector to get speed of this object\r\n\t\t\tlet unitVector = this.getUnitVector();\r\n\r\n\t\t\t// 75 pixels total movement per second\r\n\t\t\tthis.velocity.x = unitVector.x * this.speed;\r\n\t\t\tthis.velocity.y = unitVector.y * this.speed;\r\n\t\t}\r\n\t}\r\n\r\n\t// changes this.facing letiable based on velocity of x\r\n\tupdateDirection() {\r\n\t\tif (this.velocity.x < 0) {\r\n\t\t\tthis.facing = \"left\";\r\n\t\t} else if (this.velocity.x > 0) {\r\n\t\t\tthis.facing = \"right\";\r\n\t\t}\r\n\t}\r\n\r\n\t// hits the other player passed in\r\n\t// changes other velocity\r\n\t// sets this character attack on cooldown\r\n\t// TODO: maybe random damage instead of 10?\r\n\thit(other, dt) {\r\n\t\tif (this.status == this.states.ATTACKING) {\r\n\t\t} else {\r\n\t\t\tother.setTimeKnockedback(dt);\r\n\r\n\t\t\tlet otherV = other.getVelocity();\r\n\r\n\t\t\tother.addPosition(Math.sign(otherV.x) * -10, Math.sign(otherV.y) * -10);\r\n\r\n\t\t\tother.setVX(otherV.x * -7.5 + (Math.floor(Math.random() * 5) * Math.random() < 0.5 ? -1 : 1));\r\n\t\t\tother.setVY(otherV.y * -7.5 + (Math.floor(Math.random() * 5) * Math.random() < 0.5 ? -1 : 1));\r\n\r\n\t\t\tthis.attackTimer = this.attackCD;\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/character.js?");

/***/ }),

/***/ "./src/collision.js":
/*!**************************!*\
  !*** ./src/collision.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Collision)\n/* harmony export */ });\nclass Collision {\r\n\t// collision class that is used to handle collisions\r\n\tconstructor(obj1, obj2, dir, time) {\r\n\t\tthis.objectIndex1 = obj1;\r\n\t\tthis.objectIndex2 = obj2;\r\n\t\tthis.direction = dir;\r\n\t\tthis.time = time;\r\n\t}\r\n\r\n\tgetObj1() {\r\n\t\treturn this.objectIndex1;\r\n\t}\r\n\r\n\tgetObj2() {\r\n\t\treturn this.objectIndex2;\r\n\t}\r\n\r\n\tgetTime() {\r\n\t\treturn this.time;\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/collision.js?");

/***/ }),

/***/ "./src/damagesplat.js":
/*!****************************!*\
  !*** ./src/damagesplat.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ DamageSplat)\n/* harmony export */ });\nclass DamageSplat {\r\n\tconstructor(pos, number, assets) {\r\n\t\tthis.pos = pos;\r\n\t\tthis.number = number;\r\n\t\tthis.assets = assets;\r\n\t\tthis.time = 0;\r\n\t\tthis.width = 40;\r\n\t\tthis.height = 40;\r\n\t}\r\n\r\n\tupdateTime(step) {\r\n\t\tthis.time += step;\r\n\t}\r\n\r\n\tgetTime() {\r\n\t\treturn this.time;\r\n\t}\r\n\r\n\t// draws damage splat\r\n\tdraw(ctx) {\r\n\t\t// draws blue splat if damage is 0 and red otherwise\r\n\t\tif (this.number == 0) {\r\n\t\t\tctx.drawImage(this.assets[1], this.pos.x, this.pos.y);\r\n\t\t} else {\r\n\t\t\tctx.drawImage(this.assets[0], this.pos.x, this.pos.y);\r\n\t\t}\r\n\t\tctx.fillStyle = \"white\";\r\n\t\tctx.fillText(\"\" + this.number, this.pos.x + this.width / 2 - ctx.measureText(\"\" + this.number).width / 2, this.pos.y + this.height / 2 + 5);\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/damagesplat.js?");

/***/ }),

/***/ "./src/firzen.js":
/*!***********************!*\
  !*** ./src/firzen.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Firzen)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Firzen extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageWinning = this.assets[1];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[4, 1],\r\n\t\t\t\t[7, 1],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[4, 0],\r\n\t\t\t\t[10, 0],\r\n\t\t\t],\r\n\t\t};\r\n\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/firzen.js?");

/***/ }),

/***/ "./src/henry.js":
/*!**********************!*\
  !*** ./src/henry.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Henry)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Henry extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageAttacking = this.assets[1];\r\n\t\tthis.imageWinning = this.assets[2];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[0, 0],\r\n\t\t\t\t[4, 0],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[0, 0],\r\n\t\t\t\t[4, 0],\r\n\t\t\t],\r\n\t\t};\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n\r\n\t// henry has slightly different attacking as his comes from a different sprite sheet than normal\r\n\tdrawSpriteAttacking(ctx) {\r\n\t\tvar sprite = this.getSpriteOneLoop(\"attacking\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/henry.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _woody_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./woody.js */ \"./src/woody.js\");\n/* harmony import */ var _firzen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./firzen.js */ \"./src/firzen.js\");\n/* harmony import */ var _henry_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./henry.js */ \"./src/henry.js\");\n/* harmony import */ var _justin_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./justin.js */ \"./src/justin.js\");\n/* harmony import */ var _collision_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collision.js */ \"./src/collision.js\");\n/* harmony import */ var _damagesplat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./damagesplat.js */ \"./src/damagesplat.js\");\n/* harmony import */ var _UI_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./UI.js */ \"./src/UI.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Game {\r\n\tconstructor() {\r\n\t\tthis.MIN_STEP = 10;\r\n\t\tthis.SPRITE_HEIGHT = 80;\r\n\t\tthis.players = 0;\r\n\r\n\t\tthis.lastTime = 0;\r\n\r\n\t\t// states of each character\r\n\t\tthis.states = {\r\n\t\t\tRUNNING: \"running\",\r\n\t\t\tKNOCKEDBACK: \"knockedback\",\r\n\t\t\tATTACKING: \"attacking\",\r\n\t\t\tWINNING: \"winning\",\r\n\t\t\tDEAD: \"dead\",\r\n\t\t};\r\n\r\n\t\tthis.assets = {};\r\n\r\n\t\t// clamping frames so they are not too long or short\r\n\t\tthis.typicalFrame = 16;\r\n\t\tthis.smallestFrame = 14;\r\n\t\tthis.longestFrame = 50;\r\n\r\n\t\t// arrays to store info\r\n\t\tthis.names = [];\r\n\t\tthis.characterList = [];\r\n\r\n\t\t// store all char at beginning\r\n\t\tthis.beginning = [];\r\n\r\n\t\t// arrays to store names and actual objects of dead chars\r\n\t\tthis.deathListNames = [];\r\n\t\tthis.deathListObjects = [];\r\n\r\n\t\t// array for damage splats\r\n\t\tthis.damageSplats = [];\r\n\r\n\t\t// height and width of canvas\r\n\t\tthis.GAME_WIDTH = 960;\r\n\t\tthis.GAME_HEIGHT = 720;\r\n\r\n\t\t// DOM elements that are needed\r\n\t\tthis.DOMElements = {\r\n\t\t\tdeathlist: document.getElementById(\"deathlist\"),\r\n\t\t\tcanvas: document.getElementById(\"gameScreen\"),\r\n\t\t\tctx: document.getElementById(\"gameScreen\").getContext(\"2d\"),\r\n\t\t};\r\n\t}\r\n\r\n\t// load all assets into assets variable\r\n\tinitAssets() {\r\n\t\tlet woodyImage = new Image();\r\n\t\twoodyImage.src = \"Assets/woody.png\";\r\n\r\n\t\tlet woodyImageWinning = new Image();\r\n\t\twoodyImageWinning.src = \"Assets/woody2.png\";\r\n\r\n\t\tthis.assets.woodyAssets = [woodyImage, woodyImageWinning];\r\n\r\n\t\tlet firzenImage = new Image();\r\n\t\tfirzenImage.src = \"Assets/firzen.png\";\r\n\r\n\t\tlet firzenImageWinning = new Image();\r\n\t\tfirzenImageWinning.src = \"Assets/firzen1.png\";\r\n\r\n\t\tthis.assets.firzenAssets = [firzenImage, firzenImageWinning];\r\n\r\n\t\tlet henryImage = new Image();\r\n\t\thenryImage.src = \"Assets/henry.png\";\r\n\r\n\t\tlet henryImageAttacking = new Image();\r\n\t\thenryImageAttacking.src = \"Assets/henryAttacking.png\";\r\n\r\n\t\tlet henryImageWinning = new Image();\r\n\t\thenryImageWinning.src = \"Assets/henry2.png\";\r\n\r\n\t\tthis.assets.henryAssets = [henryImage, henryImageAttacking, henryImageWinning];\r\n\r\n\t\tlet justinImage = new Image();\r\n\t\tjustinImage.src = \"Assets/justin0.png\";\r\n\r\n\t\tlet justinImageAttacking = new Image();\r\n\t\tjustinImageAttacking.src = \"Assets/justin1.png\";\r\n\r\n\t\tthis.assets.justinAssets = [justinImage, justinImageAttacking];\r\n\r\n\t\tlet bg = new Image();\r\n\t\tbg.src = \"Assets/bg1.png\";\r\n\t\tthis.assets.bg = bg;\r\n\r\n\t\tlet damageSplatRed = new Image();\r\n\t\tlet damageSplatBlue = new Image();\r\n\r\n\t\tdamageSplatRed.src = \"Assets/dmgsplat_red.png\";\r\n\t\tdamageSplatBlue.src = \"Assets/dmgsplat_blue.png\";\r\n\r\n\t\tthis.assets.damageSplats = [damageSplatRed, damageSplatBlue];\r\n\t}\r\n\r\n\tinitStartButton() {\r\n\t\tconst boundHandleStartButtonPress = this.handleStartButtonPress.bind(this);\r\n\t\tdocument.getElementById(\"start\").addEventListener(\"click\", boundHandleStartButtonPress);\r\n\t}\r\n\r\n\tinitCanvas() {\r\n\t\tthis.DOMElements.canvas.height = 720;\r\n\t\tthis.DOMElements.canvas.width = 960;\r\n\r\n\t\tthis.DOMElements.ctx.font = \"16px Arial\";\r\n\r\n\t\tthis.DOMElements.ctx.clearRect(0, 0, this.DOMElements.canvas.width, this.DOMElements.canvas.height);\r\n\t}\r\n\r\n\thandleStartButtonPress() {\r\n\t\t// gets all names entered in textbox, one name per each line, gets rid of lines with nothing in them\r\n\t\tlet names = document.getElementById(\"entries\").value.split(\"\\n\");\r\n\t\tfor (let i = names.length - 1; i > -1; i--) {\r\n\t\t\tif (names[i].trim() == \"\") {\r\n\t\t\t\tnames.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// max names of 24 so screen doesn't get too overcrowded\r\n\t\tif (names.length > 24) {\r\n\t\t\tnames = [];\r\n\t\t}\r\n\r\n\t\tthis.resetGame();\r\n\t\tthis.names = names;\r\n\t\tthis.beginning.push(names);\r\n\t\tthis.players = names.length;\r\n\r\n\t\t// generates character location\r\n\t\tfor (let i = 0; i < names.length; i++) {\r\n\t\t\tlet pos = this.getNewCharacterPosition();\r\n\t\t\tlet rand = Math.floor(Math.random() * 4);\r\n\r\n\t\t\t// generates a random character out of 4\r\n\t\t\t// TODO: add more characters\r\n\r\n\t\t\tlet character = this.createNewCharacter(rand, pos, i);\r\n\r\n\t\t\tif (character != -1) this.characterList.push(character);\r\n\t\t}\r\n\t}\r\n\r\n\tcreateNewCharacter(rand, pos, characterNum) {\r\n\t\tif (rand == 0)\r\n\t\t\treturn new _henry_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\r\n\t\t\t\tthis.GAME_WIDTH,\r\n\t\t\t\tthis.GAME_HEIGHT,\r\n\t\t\t\tthis.names[characterNum],\r\n\t\t\t\tpos,\r\n\t\t\t\tcharacterNum,\r\n\t\t\t\tthis.assets.henryAssets,\r\n\t\t\t\tthis.DOMElements.ctx\r\n\t\t\t);\r\n\t\telse if (rand == 1)\r\n\t\t\treturn new _firzen_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\r\n\t\t\t\tthis.GAME_WIDTH,\r\n\t\t\t\tthis.GAME_HEIGHT,\r\n\t\t\t\tthis.names[characterNum],\r\n\t\t\t\tpos,\r\n\t\t\t\tcharacterNum,\r\n\t\t\t\tthis.assets.firzenAssets,\r\n\t\t\t\tthis.DOMElements.ctx\r\n\t\t\t);\r\n\t\telse if (rand == 2)\r\n\t\t\treturn new _woody_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](\r\n\t\t\t\tthis.GAME_WIDTH,\r\n\t\t\t\tthis.GAME_HEIGHT,\r\n\t\t\t\tthis.names[characterNum],\r\n\t\t\t\tpos,\r\n\t\t\t\tcharacterNum,\r\n\t\t\t\tthis.assets.woodyAssets,\r\n\t\t\t\tthis.DOMElements.ctx\r\n\t\t\t);\r\n\t\telse if (rand == 3)\r\n\t\t\treturn new _justin_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\r\n\t\t\t\tthis.GAME_WIDTH,\r\n\t\t\t\tthis.GAME_HEIGHT,\r\n\t\t\t\tthis.names[characterNum],\r\n\t\t\t\tpos,\r\n\t\t\t\tcharacterNum,\r\n\t\t\t\tthis.assets.justinAssets,\r\n\t\t\t\tthis.DOMElements.ctx\r\n\t\t\t);\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\tgetNewCharacterPosition() {\r\n\t\tlet xp = this.getRandomTile(6) * this.SPRITE_HEIGHT * 2 + this.SPRITE_HEIGHT;\r\n\t\tlet yp = this.getRandomTile(3) * this.SPRITE_HEIGHT * 2 + this.SPRITE_HEIGHT;\r\n\r\n\t\twhile (this.checkXYOverlap(xp, yp, this.characterList)) {\r\n\t\t\txp = this.getRandomTile(6) * this.SPRITE_HEIGHT * 2 + this.SPRITE_HEIGHT;\r\n\t\t\typ = this.getRandomTile(4) * this.SPRITE_HEIGHT * 2 + this.SPRITE_HEIGHT;\r\n\t\t}\r\n\r\n\t\treturn { x: xp, y: yp };\r\n\t}\r\n\r\n\tresetGame() {\r\n\t\tthis.beginning = [];\r\n\t\tthis.deathListNames = [];\r\n\t\tthis.deathListObjects = [];\r\n\t\tthis.characterList = [];\r\n\t\tthis.damageSplats = [];\r\n\t}\r\n\r\n\t// gameloop that controls the game\r\n\tgameLoop(timestamp) {\r\n\t\tlet deltaTime = timestamp - this.lastTime;\r\n\t\tif (deltaTime > this.longestFrame) deltaTime = this.typicalFrame;\r\n\r\n\t\tthis.lastTime = timestamp;\r\n\r\n\t\tthis.DOMElements.ctx.clearRect(0, 0, this.DOMElements.canvas.width, this.DOMElements.canvas.height);\r\n\r\n\t\t// controls all calculations of each character\r\n\t\tthis.updateGame(deltaTime);\r\n\r\n\t\t// Finds if game has ended and sends data to server as a JSON\r\n\t\tif (this.deathListNames.length === this.players - 1) {\r\n\t\t\tthis.deathListNames.push(this.characterList[0].getName());\r\n\r\n\t\t\tconst data = { deathListNames: this.deathListNames, beginning: this.beginning };\r\n\r\n\t\t\tconst options = {\r\n\t\t\t\tmethod: \"POST\",\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t\"Content-Type\": \"application/json\",\r\n\t\t\t\t},\r\n\t\t\t\tbody: JSON.stringify(data),\r\n\t\t\t};\r\n\r\n\t\t\tfetch(\"/api\", options)\r\n\t\t\t\t.then((response) => response.json())\r\n\t\t\t\t.then((json) => {\r\n\t\t\t\t\tconsole.log(json);\r\n\t\t\t\t});\r\n\r\n\t\t\tthis.players = -999;\r\n\t\t}\r\n\t\tconst boundGameLoop = this.gameLoop.bind(this);\r\n\t\trequestAnimationFrame(boundGameLoop);\r\n\t}\r\n\r\n\t// handles all calculations of characters by time\r\n\tupdateGame(dt) {\r\n\t\tlet step = dt;\r\n\t\tdo {\r\n\t\t\tthis.resolveAllCollisions(step);\r\n\t\t\t// drawing portion\r\n\t\t\tthis.drawAllElements(step);\r\n\r\n\t\t\tdt -= step;\r\n\t\t\tstep = dt;\r\n\t\t} while (dt > 0);\r\n\t}\r\n\r\n\tresolveAllCollisions(step) {\r\n\t\t// first finds if there is at least one collision between characters\r\n\t\tlet hit = this.findFirstCollision(step);\r\n\r\n\t\t// if there is at least one collision, find all collisions by turning them into collision objects, handle them, and move each character\r\n\t\tif (hit != null) {\r\n\t\t\tstep = Math.max(hit.getTime(), this.MIN_STEP);\r\n\t\t\tthis.updateObjects(step);\r\n\t\t\tthis.handleCollisions(step);\r\n\t\t\t// else just move each character\r\n\t\t} else {\r\n\t\t\tthis.updateObjects(step);\r\n\t\t}\r\n\t}\r\n\r\n\tdrawAllElements(step) {\r\n\t\t// draw bg\r\n\t\tthis.DOMElements.ctx.drawImage(this.assets.bg, 0, 0);\r\n\r\n\t\t// draw dead characters as lying prone on the ground\r\n\t\tfor (let i = 0; i < this.deathListObjects.length; i++) {\r\n\t\t\tthis.deathListObjects[i].draw(this.DOMElements.ctx, step);\r\n\t\t}\r\n\r\n\t\t//draw alive characters either as KBed or running or winning\r\n\t\tfor (let i = 0; i < this.characterList.length; i++) {\r\n\t\t\tthis.characterList[i].draw(this.DOMElements.ctx, step);\r\n\t\t}\r\n\r\n\t\t// draw damage splats\r\n\t\tfor (let i = 0; i < this.damageSplats.length; i++) {\r\n\t\t\tthis.damageSplats[i].draw(this.DOMElements.ctx);\r\n\r\n\t\t\tthis.damageSplats[i].updateTime(step);\r\n\t\t\tif (this.damageSplats[i].getTime() > 2000) {\r\n\t\t\t\tthis.damageSplats.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// finds if there is only 1 character left alive and makes him celebrate\r\n\t\tif (this.characterList.length == 1) {\r\n\t\t\tif (this.characterList[0].getStatus() != this.states.WINNING) {\r\n\t\t\t\tthis.characterList[0].setSprite(this.states.WINNING);\r\n\t\t\t}\r\n\t\t\tthis.characterList[0].setStatus(this.states.WINNING);\r\n\t\t}\r\n\t}\r\n\r\n\tupdateDeathDOM() {\r\n\t\t// updates list of dead characters based on characters that are in the deathListNames array\r\n\t\tthis.DOMElements.deathlist.innerHTML = \"\";\r\n\t\tfor (let i = 0; i < this.deathListNames.length; i++) {\r\n\t\t\tthis.DOMElements.deathlist.innerHTML = this.DOMElements.deathlist.innerHTML + (i + 1) + \". \" + this.deathListNames[i] + \"<br />\";\r\n\t\t}\r\n\t}\r\n\r\n\t// function that handles moving the characters around and recognising when they are dead\r\n\tupdateObjects(step) {\r\n\t\tfor (let i = 0; i < this.characterList.length; i++) {\r\n\t\t\tlet character = this.characterList[i];\r\n\t\t\tlet pos = character.getPosition();\r\n\t\t\tlet v = character.getVelocity();\r\n\r\n\t\t\t// keeps characters within a boundary\r\n\t\t\tcharacter.keepInside();\r\n\r\n\t\t\t// if character has a cooldown on their attack, reduce it by time passed\r\n\t\t\tcharacter.cooldownAttackTimer(step);\r\n\r\n\t\t\t// if character is dead, push him into dead list and remove him from alive list\r\n\t\t\tif (character.isDead()) {\r\n\t\t\t\tthis.deathListNames.push(character.getName());\r\n\t\t\t\tthis.updateDeathDOM();\r\n\r\n\t\t\t\tcharacter.setStatus(this.states.DEAD);\r\n\t\t\t\tthis.deathListObjects.push(character);\r\n\r\n\t\t\t\tthis.characterList.splice(i, 1);\r\n\t\t\t\ti--;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// handles if character is KBed by another - pushes them back in the opposite direction they were running in\r\n\t\t\tif (character.getStatus() == this.states.KNOCKEDBACK) {\r\n\t\t\t\tcharacter.setVX(v.x * 0.95);\r\n\t\t\t\tcharacter.setVY(v.y * 0.95);\r\n\t\t\t\tcharacter.setPosition(pos.x + (step * v.x) / 1000, pos.y + (step * v.y) / 1000);\r\n\t\t\t\tcharacter.addTimeKnockedback(step);\r\n\r\n\t\t\t\t// if they reach the time limit on being KBed, reset them back to running state\r\n\t\t\t\tif (character.getTimeKnockedback() > 1000) {\r\n\t\t\t\t\tcharacter.setStatus(this.states.RUNNING);\r\n\t\t\t\t\tcharacter.setSprite(this.states.RUNNING);\r\n\t\t\t\t\tcharacter.setTimeKnockedback(0);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// otherwise if they are not KBed, set a goal destination to the nearest enemy where they will run to\r\n\t\t\t} else {\r\n\t\t\t\tcharacter.setGoal(character.getClosestEnemy(this.characterList));\r\n\t\t\t\tcharacter.updateVelocities();\r\n\r\n\t\t\t\tcharacter.setPosition(pos.x + (step * v.x) / 1000, pos.y + (step * v.y) / 1000);\r\n\t\t\t}\r\n\r\n\t\t\t// if a character has completed an attack animation, reset them back to running state.\r\n\t\t\tif (character.getAttackTimer() < character.getTimeForAttackAnimation() && character.getStatus() == this.states.ATTACKING) {\r\n\t\t\t\tcharacter.setSprite(this.states.RUNNING);\r\n\t\t\t\tcharacter.setStatus(this.states.RUNNING);\r\n\t\t\t}\r\n\r\n\t\t\t// if character is running, update the direction they face (left if negative movement, right if positive movement)\r\n\t\t\tif (character.getStatus() == this.states.RUNNING) {\r\n\t\t\t\tcharacter.updateDirection();\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// handles each collision - is passed a collision and decides who gets hit and who is the one hitting\r\n\t// returns dmg number and character that gets hit\r\n\tupdateVelocities(collision, step) {\r\n\t\tlet obj1 = collision.getObj1();\r\n\t\tlet obj2 = collision.getObj2();\r\n\r\n\t\tlet rand = Math.floor(Math.random() * 15);\r\n\r\n\t\t// make sure that in the collision object, the two colliding objects are not null\r\n\t\tif (obj1 != null && obj2 != null) {\r\n\t\t\t//if they are not nulls, check their attack cooldown timers\r\n\r\n\t\t\t//if obj1 is ready to attack but obj2 isn't, obj2 will definitely getting hit\r\n\t\t\tif (obj1.getAttackTimer() == 0 && obj2.getAttackTimer() != 0) {\r\n\t\t\t\tif (obj1.getStatus() != this.states.KNOCKEDBACK && obj2.getStatus() != this.states.KNOCKEDBACK) {\r\n\t\t\t\t\tobj1.hit(obj2, step);\r\n\t\t\t\t\tthis.updateStatus(obj1, obj2);\r\n\t\t\t\t\tthis.updateHealth(obj1, obj2, rand);\r\n\t\t\t\t\treturn [obj2, rand];\r\n\t\t\t\t}\r\n\t\t\t\t//vice versa\r\n\t\t\t} else if (obj1.getAttackTimer() != 0 && obj2.getAttackTimer() == 0) {\r\n\t\t\t\tif (obj1.getStatus() != this.states.KNOCKEDBACK && obj2.getStatus() != this.states.KNOCKEDBACK) {\r\n\t\t\t\t\tobj2.hit(obj1, step);\r\n\t\t\t\t\tthis.updateStatus(obj2, obj1);\r\n\t\t\t\t\tthis.updateHealth(obj2, obj1, rand);\r\n\t\t\t\t\treturn [obj1, rand];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if both characters have their attack ready, it will be a 50/50 on who gets hit\r\n\t\t\t} else if (obj1.getAttackTimer() == 0 && obj2.getAttackTimer() == 0) {\r\n\t\t\t\tlet coinflip = Math.floor(Math.random() * 2);\r\n\r\n\t\t\t\tif (coinflip == 0) {\r\n\t\t\t\t\tif (obj1.getStatus() != this.states.KNOCKEDBACK && obj2.getStatus() != this.states.KNOCKEDBACK) {\r\n\t\t\t\t\t\tobj1.hit(obj2, step);\r\n\t\t\t\t\t\tthis.updateStatus(obj1, obj2);\r\n\t\t\t\t\t\tthis.updateHealth(obj1, obj2, rand);\r\n\t\t\t\t\t\treturn [obj2, rand];\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (obj1.getStatus() != this.states.KNOCKEDBACK && obj2.getStatus() != this.states.KNOCKEDBACK) {\r\n\t\t\t\t\t\tobj2.hit(obj1, step);\r\n\t\t\t\t\t\tthis.updateStatus(obj2, obj1);\r\n\t\t\t\t\t\tthis.updateHealth(obj2, obj1, rand);\r\n\t\t\t\t\t\treturn [obj1, rand];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// function that handles all collisions\r\n\thandleCollisions(step) {\r\n\t\t// finds all collisions, set up unique collisions and charactersSeen as an collision between Char1 and Char2 is also a collision between Char2 and Char1\r\n\t\t// we don't want that to register as two seperate collisions\r\n\t\tlet allCollisions = this.findAllCollisions(step);\r\n\t\tlet uniqueCollisions = [];\r\n\t\tlet charactersSeen = [];\r\n\r\n\t\t// look at each individual collision\r\n\t\tfor (let i = 0; i < allCollisions.length; i++) {\r\n\t\t\tlet obj1 = allCollisions[i].getObj1();\r\n\t\t\tlet obj2 = allCollisions[i].getObj2();\r\n\r\n\t\t\t// if they are both not in the characterSeen array, push their unique ID and their collision in\r\n\t\t\tif (!charactersSeen.includes(obj1.getID()) && !charactersSeen.includes(obj2.getID())) {\r\n\t\t\t\tcharactersSeen.push(obj1.getID());\r\n\t\t\t\tcharactersSeen.push(obj2.getID());\r\n\t\t\t\tuniqueCollisions.push(allCollisions[i]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// using all unique collisions, handle each unique collision using the function above\r\n\t\tfor (let collision of uniqueCollisions) {\r\n\t\t\t// info contains who was hit and the damage\r\n\t\t\tlet info = this.updateVelocities(collision, step);\r\n\t\t\tif (info != undefined) {\r\n\t\t\t\tthis.createDamageSplats(info[0].getPosition(), info[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// finds all collisions by comparing each character to see if their hitboxes overlap and returns a array of all collisions\r\n\tfindAllCollisions(dt) {\r\n\t\tlet collisions = [];\r\n\t\tfor (let i = 0; i < this.characterList.length; i++) {\r\n\t\t\tfor (let j = i + 1; j < this.characterList.length; j++) {\r\n\t\t\t\tlet hit = this.findCollision(i, j, dt);\r\n\t\t\t\tif (hit != null) {\r\n\t\t\t\t\tcollisions.push(hit);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn collisions;\r\n\t}\r\n\r\n\t// function that finds 1 collision to see if we need to run findAllCollisions func\r\n\tfindFirstCollision(dt) {\r\n\t\tfor (let i = 0; i < this.characterList.length; i++) {\r\n\t\t\tfor (let j = i + 1; j < this.characterList.length; j++) {\r\n\t\t\t\tlet hit = this.findCollision(i, j, dt);\r\n\t\t\t\tif (hit != null) {\r\n\t\t\t\t\treturn hit;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// checks to see if there is a collision between characters at index i and j by checking overlaps of hitboxes\r\n\t// if there is, create a Collision object and return it to findAllCollisions func\r\n\tfindCollision(i, j, dt) {\r\n\t\tlet obj1 = this.characterList[i];\r\n\t\tlet obj2 = this.characterList[j];\r\n\t\tlet obj1Pos = obj1.getPosition();\r\n\t\tlet obj2Pos = obj2.getPosition();\r\n\t\tif (\r\n\t\t\tobj1Pos.x <= obj2Pos.x + obj2.getWidth() &&\r\n\t\t\tobj1Pos.x + obj1.getWidth() >= obj2Pos.x &&\r\n\t\t\tobj1Pos.y + obj1.getHeight() >= obj2Pos.y &&\r\n\t\t\tobj1Pos.y <= obj2Pos.y + obj2.getHeight()\r\n\t\t) {\r\n\t\t\tlet dir = 0;\r\n\t\t\tlet col = new _collision_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"](obj1, obj2, dir, dt);\r\n\t\t\treturn col;\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// creates damage splat object and appends it to the damage splat list\r\n\tcreateDamageSplats(location, number) {\r\n\t\tlet damageSplat = new _damagesplat_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](location, number, this.assets.damageSplats);\r\n\t\tthis.damageSplats.push(damageSplat);\r\n\t}\r\n\r\n\t// updates statuses between two characters hitting each other - one hits, one gets KBed\r\n\tupdateStatus(obj1, obj2) {\r\n\t\t// obj1 is the hitter, obj2 is the hittee(is that a word?)\r\n\t\tobj1.setStatus(this.states.ATTACKING);\r\n\t\tobj1.setSprite(this.states.ATTACKING);\r\n\r\n\t\tobj2.setStatus(this.states.KNOCKEDBACK);\r\n\t\tobj2.setSprite(this.states.KNOCKEDBACK);\r\n\t}\r\n\r\n\t// updates health after a collision\r\n\tupdateHealth(obj1, obj2, dmg) {\r\n\t\t// obj1 is the hitter, obj2 is the hittee\r\n\t\t//let dmg = obj1.getDmg();\r\n\t\tobj2.minusHealth(dmg);\r\n\t}\r\n\r\n\t// function used when generating characters at the beginning to make sure when they spawn they\r\n\t// do not overlap - keeps generating random coords until no overlaps are found\r\n\tcheckXYOverlap(xpos, ypos, characterList) {\r\n\t\tfor (const character of characterList) {\r\n\t\t\tif (character.getPosition().x == xpos && character.getPosition().y == ypos) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\t// gets a random 80x80 tile\r\n\tgetRandomTile(max_tiles) {\r\n\t\t// tile size of 80x80 - 9 up, 12 across\r\n\t\treturn Math.floor(Math.random() * max_tiles);\r\n\t}\r\n}\r\n\r\nconst UIManager = new _UI_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]();\r\nUIManager.initArrow();\r\nUIManager.initResizeableNav();\r\nUIManager.initInfoTabs();\r\n\r\nconst game = new Game();\r\ngame.initAssets();\r\ngame.initStartButton();\r\ngame.initCanvas();\r\ngame.gameLoop(0);\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/index.js?");

/***/ }),

/***/ "./src/justin.js":
/*!***********************!*\
  !*** ./src/justin.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Justin)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Justin extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageAttacking = this.assets[1];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[0, 1],\r\n\t\t\t\t[7, 1],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[2, 4],\r\n\t\t\t\t[6, 4],\r\n\t\t\t],\r\n\t\t};\r\n\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n\r\n\t// custom drawing methods as they use different sprite sheets\r\n\tdrawSpriteAttacking(ctx) {\r\n\t\tlet sprite = this.getSpriteOneLoop(\"attacking\");\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.imageAttacking, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n\r\n\tdrawSpriteWinning(ctx) {\r\n\t\tlet sprite = this.getSpriteConstantLoop(\"winning\");\r\n\t\tctx.fillStyle = \"fuchsia\";\r\n\t\tctx.fillText(\"WINNER\", this.position.x + this.width / 2 - ctx.measureText(\"WINNER\").width / 2, this.position.y - 10);\r\n\t\tif (this.facing == this.directions.RIGHT) {\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, this.position.x, this.position.y, this.width, this.height);\r\n\t\t} else {\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t\tctx.drawImage(this.image, sprite.x, sprite.y, 80, 80, -this.position.x - this.width, this.position.y, this.width, this.height);\r\n\t\t\tctx.scale(-1, 1);\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/justin.js?");

/***/ }),

/***/ "./src/woody.js":
/*!**********************!*\
  !*** ./src/woody.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Woody)\n/* harmony export */ });\n/* harmony import */ var _character_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character.js */ \"./src/character.js\");\n\r\n\r\nclass Woody extends _character_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\r\n\tconstructor(gameWidth, gameHeight, name, pos, image, id, assets, ctx) {\r\n\t\tsuper(gameWidth, gameHeight, name, pos, image, id, assets, ctx);\r\n\r\n\t\tthis.image = this.assets[0];\r\n\t\tthis.imageWinning = this.assets[1];\r\n\r\n\t\t// custom column/row coords from sprite sheet\r\n\r\n\t\tthis.spriteDict = {\r\n\t\t\trunning: [\r\n\t\t\t\t[0, 2],\r\n\t\t\t\t[3, 2],\r\n\t\t\t],\r\n\t\t\tknockedback: [\r\n\t\t\t\t[0, 3],\r\n\t\t\t\t[5, 3],\r\n\t\t\t],\r\n\t\t\tattacking: [\r\n\t\t\t\t[0, 1],\r\n\t\t\t\t[3, 1],\r\n\t\t\t],\r\n\t\t\twinning: [\r\n\t\t\t\t[1, 3],\r\n\t\t\t\t[10, 3],\r\n\t\t\t],\r\n\t\t};\r\n\r\n\t\t// time needed for animation to attack\r\n\t\t// catches error if time is  < 0\r\n\t\tthis.timeforAttackAnimation =\r\n\t\t\t(this.attackCD - (this.spriteDict[\"attacking\"][1][0] - this.spriteDict[\"attacking\"][0][0]) * this.imageTimerMax) * 0.5;\r\n\t\tif (this.timeforAttackAnimation <= 0) {\r\n\t\t\tconsole.log(\"ERROR 0 for timeForAttackAnimation\");\r\n\t\t}\r\n\t}\r\n}\r\n\n\n//# sourceURL=webpack://team-selector-updated/./src/woody.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ })()
;